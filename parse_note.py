#!/usr/bin/env python
# vim: set fileencoding=utf-8
# Copyright (C) 2012, Nicholas Knouf
#
# This file is part of quill_utils
#
# quill_utils is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

import StringIO
import os
import shutil
import struct
import sys
import tarfile
import tempfile
import uuid

from optparse import OptionParser

import cairo

__version__ = 0.01

class QuillPage(object):
    # Purely arbitrary
    # A line-width of 0.003 gives a good visual approximation to Quill's pen thickness of 5
    pen_scale_factor = float(5.0/0.003)

    def __init__(self, page_file=None, page_number=1):
        self.page_number = page_number
        fp = self.fp = page_file
        self.version = struct.unpack(">i", fp.read(4))
        nbytes = struct.unpack(">h", fp.read(2))
        self.u = fp.read(36)
        self.tsversion = struct.unpack(">i", fp.read(4))
        
        self.ntags = struct.unpack(">i", fp.read(4))
        
        # If we have tags
        self.tags = []
        for x in xrange(self.ntags[0]):
            self.tversion = struct.unpack(">i", fp.read(4))
            assert self.tversion[0] == 1
            nbytes = struct.unpack(">h", fp.read(2))
            tag = {}
            tag["tag"] = fp.read(nbytes[0]).decode("utf-8")
            tag["autogenerated"] = struct.unpack(">?", fp.read(1))[0]
            tag["ctime"] = struct.unpack(">q", fp.read(8))[0]
            dummy = struct.unpack(">q", fp.read(8))
            self.tags.append(tag)
        
        foo = struct.unpack(">i", fp.read(4))
        foo = struct.unpack(">i", fp.read(4))
        
        self.paper_type = struct.unpack(">i", fp.read(4))
        self.nimages = struct.unpack(">i", fp.read(4))
        dummy = struct.unpack(">i", fp.read(4))
        self.read_only = struct.unpack(">?", fp.read(1))
        self.aspect_ratio = struct.unpack(">f", fp.read(4))[0]
        self.nstrokes = struct.unpack(">i", fp.read(4))

        self.height = 1100
        self.width = self.height * self.aspect_ratio

    def save_svg(self, filename):
        surface = cairo.SVGSurface(filename, self.width, self.height)
        cr = cairo.Context(surface)
        self._draw(cr)
        surface.finish()

    def save_pdf(self, filename):
        surface = cairo.PDFSurface(filename, self.width, self.height)
        cr = cairo.Context(surface)
        self._draw(cr)
        surface.finish()

    def save_ps(self, filename):
        surface = cairo.PSSurface(filename, self.width, self.height)
        cr = cairo.Context(surface)
        self._draw(cr)
        surface.finish()

    def _draw(self, cairo_context):
        cr = cairo_context
        cr.set_source_rgb(0, 0, 0)
        cr.set_line_cap(cairo.LINE_CAP_ROUND)
        cr.set_line_join(cairo.LINE_JOIN_ROUND)
        # cr.translate(.010, .010)
        cr.set_line_width(0.003)
        cr.scale(self.height, self.height)
        
        fp = self.fp
        for stroke in xrange(self.nstrokes[0]):
            sversion = struct.unpack(">i", fp.read(4))
            pen_color = struct.unpack(">i", fp.read(4))
            red = (pen_color[0] >> 16) & 0xFF
            green = (pen_color[0] >> 8) & 0xFF
            blue = pen_color[0] & 0xFF
            cr.set_source_rgb(float(red/255.0), float(green/255.0), float(blue/255.0))
            pen_thickness = struct.unpack(">i", fp.read(4))
            pen_thickness_factor = float(pen_thickness[0])/self.pen_scale_factor
            toolint = struct.unpack(">i", fp.read(4))
            fountain_pen = (toolint == (0,))
            N = struct.unpack(">i", fp.read(4))
        
            points = []
            for instance in xrange(N[0]):
                x = struct.unpack(">f", fp.read(4))
                y = struct.unpack(">f", fp.read(4))
                p = struct.unpack(">f", fp.read(4))
                points.append((x[0], y[0], p[0]))

            if fountain_pen:
                # width changes, each segment is its own stroke
                for point in xrange(len(points) - 1):
                    cr.set_line_width(pen_thickness_factor * ((points[point][2] + points[point+1][2])/2))
                    cr.move_to(points[point][0], points[point][1])
                    cr.line_to(points[point + 1][0], points[point + 1][1])
                    cr.stroke()
            else:
                # constant width, join all segment into one stroke
                cr.set_line_width(pen_thickness_factor)
                for point in xrange(len(points) - 1):
                    cr.move_to(points[point][0], points[point][1])
                    cr.line_to(points[point + 1][0], points[point + 1][1])
                cr.stroke()
        
        self.nlines = struct.unpack(">i", fp.read(4))
        dummy = struct.unpack(">i", fp.read(4))
        self.ntext = struct.unpack(">i", fp.read(4))


class QuillIndex(object):
    def __init__(self, index_file):
        fp = index_file
        self.version = struct.unpack(">i", fp.read(4))
        self.npages = struct.unpack(">i", fp.read(4))
        
        self.page_uuids = []
        for x in xrange(self.npages[0]):
            nbytes = struct.unpack(">h", fp.read(2))
            u = fp.read(36)
            self.page_uuids.append(u)
        
        self.currentPage = struct.unpack(">i", fp.read(4))
        
        nbytes = struct.unpack(">h", fp.read(2))
        self.title = fp.read(nbytes[0])
        
        self.ctime = struct.unpack(">q", fp.read(8))
        self.mtime = struct.unpack(">q", fp.read(8))
        nbytes = struct.unpack(">h", fp.read(2))
        self.u = fp.read(36)

    def __repr__(self):
        s =  'File version: '+str(self.version)+'\n'
        s += 'Title: ' + self.title + '\n'
        s += 'ctime: ' + str(self.ctime) + '\n'
        s += 'mtime: ' + str(self.mtime) + '\n'
        for i,p in enumerate(self.page_uuids):
            s += 'page ' + str(i) + ': ' + p + '\n'
        return s


if __name__ == "__main__":

    parser = OptionParser()
    parser.add_option("-f", "--filename", dest="filename", help="Quill filename to convert into SVG")
    parser.add_option("-o", "--output",   dest="output",   help="Output SVG file name (default: \"page_%03d.svg\")")
    parser.add_option("-n", "--page",     dest="page",     help="Page number to export to (default: all pages)")

    (options, arges) = parser.parse_args()
    options.ensure_value('page', None)
    options.ensure_value('output', 'page_%03d.svg')

    if (options.filename is None):
        print "Filename is required"
        sys.exit(-1)

    with tarfile.open(options.filename, "r") as t:
        index_files = [ t.extractfile(f) for f in t.getmembers() 
                        if f.name.endswith('index') ]
        if len(index_files) < 1:
            raise ValueError('Not a Quill file')
        q = QuillIndex(index_files[0])
        print q
        notebook_dir = os.path.split(index_files[0].name)[0]
        for page_number, page_uuid in enumerate(q.page_uuids):
            if options.page is not None and options.page != str(page_number+1):
                continue
            page_file = t.extractfile(notebook_dir+'/page_'+page_uuid+'.page')
            qp = QuillPage(page_file, page_number)
            try:
                output_filename = options.output % (page_number+1)
            except TypeError:
                output_filename = options.output
            if output_filename.endswith('.pdf'):
                qp.save_pdf(output_filename)
            else:
                qp.save_svg(output_filename)

